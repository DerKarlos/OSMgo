<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>EAT</title>
    <style>
    html, body { overflow:   hidden;    width: 100%;    height: 100%;     margin: 0;    padding: 0;    }
    #viewer    { touch-action: none;    width: 100%;    height: 100%;                            }
    </style>
</head>
<body>

    <canvas id='viewer' />
    <script src="https://cdn.babylonjs.com/babylon.max.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js'></script>
<!--
<script src="https://cdn.babylonjs.com/babylonjs.loaders.min.js"></script>
<script src ='lib/babylon_4.0/babylonjs.loaders.min.js'> </script>
-->
    <script type='module'>

    import { rad,grad,setDeadZone,loadGlb,Ramp,Ramp3,getUrlParameter,limit  } from './src/functions.js';
    import { HeadUpDisplay  } from './src/hud.js';
    import { Space          } from './src/space.js';
    import { Maze           } from './src/maze2d.js';
    import { User           } from './src/user.js';
    import { Control        } from './src/control.js';
//  import { WebXRPolyfill  } from './lib/webxr-polyfill.module.js.';
    const polyfill = new WebXRPolyfill(); // now, navigator.xr should exist. Returns object with .nativeWebXR
    // info: https://github.com/immersive-web/webxr-polyfill

    /**/
    // To see errors on touch devices, activate this Errorhandler producing Ggalert dialogs
    window.onerror = function(msg,url,line){
        alert(msg+'\n'+url+'\nLine: '+line)
        return true
    }
    /**/

    ///////////// MAIN /////////////////////////////////


    var webvrOk = navigator.getVRDisplays!==undefined;
    var webxrOk = navigator.xr!==undefined;
    var web_rOk = webvrOk || webxrOk;
    var httpsOk = window.location.protocol=="https:";

    console.log("po",polyfill,polyfill.nativeWebXR);
    console.log("vr",navigator.getVRDisplays);
    console.log("xr",navigator.xr);
    console.log("hs",window.location.protocol);

//    if(!httpsOk && window.location.host!="localhost") window.location = "https://"+ window.location.host + window.location.pathname;

    var seconds  = 0;
    var dSecX    = 1/60;
    var xrHelper = undefined;
    var ground   = undefined;
    var user     = undefined; // local?

    var points   = 0;
    var position0= undefined;

    window.addEventListener('DOMContentLoaded', async function() {

        //// INIT
        var canvas = document.getElementById('viewer');
        var engine = new BABYLON.Engine(canvas, true);
        var scene  = new BABYLON.Scene (engine);
        var light  = new BABYLON.HemisphericLight('hemisLight', new BABYLON.Vector3(1,1,1), scene);

        scene.clearColor = BABYLON.Color3.Black();
        scene.moveMode   = limit( getUrlParameter("m",1) * 1 ,1, 3);




        var fNEAR = 2;                          // to show the bike close by
        var fFAR  = 10*1000                     // to show the far away earth. Default: 10'000


        // here we add XR support
        const xrHelper = await scene.createDefaultXRExperienceAsync({
            //??? floorMeshes: [environment.ground]
        });
        console.log(xrHelper);
    //  console.log(xrHelper.baseExperience.camera.position)
    //  console.log(xrHelper.baseExperience.camera.globalPosition)

        xrHelper.baseExperience.camera.minZ     /= fNEAR
        xrHelper.baseExperience.camera.maxZ     *= fFAR

        xrHelper.baseExperience.onStateChangedObservable.add((state) => {
            setTimeout(function() {
                position0 = xrHelper.baseExperience.camera._position.clone();
            }, 500);
        });

        scene.hud = new HeadUpDisplay(xrHelper.baseExperience.camera,scene);
        scene.hud.out(["TEST START", "move mode: "+scene.moveMode],4000);



        var space = new Space(scene);
        space.skyDome(xrHelper)
        space.stars();

        if(scene.moveMode>1)
        user.control = new Control(user, scene, engine, xrHelper);



        //// RENDER CYCLE
        engine.runRenderLoop(function() {
            var dSec1 = engine._deltaTime / 1000
            seconds += dSec1;

            // Why is dSec so irregular??? It causes optical odds while rotating
            var fact = 6
            dSecX = ( dSecX*(fact-1)+dSec1 ) / fact;

            var x = 0; var y = 0;
            if(position0) {
                var position = xrHelper.baseExperience.camera._position.clone(); // devicePosition
                x = position.x //- position0.x;
                y = position.y //- position0.y;
//              scene.hud.out([
//                  "Poin "+points,
//                  "xPos "+Math.floor(x*1000),
//                  "yPos "+Math.floor(y*1000),
//                  "xPo0 "+Math.floor(position0.x*1000),
//                  "yPo0 "+Math.floor(position0.y*1000),
//                            ]);
            }

            points += space.animate(dSecX,x,y);



            scene.render();
        });


    });// DOMContentLoaded


    </script>

</body>
</html>
